# JAVA学习笔记-002-数据

## 基本数据类型

### 整形

#### int

存储需求：4字节32位

取值范围：-2 147 483 648 ~ 2 147 483 647

#### long

存储需求：4字节32位

取值范围：-9 223 372 036 854 775 808 - 9 223 372 036 854 775 807

#### short

存储需求：4字节32位

取值范围：-32768 ~ 32767

#### byte

存储需求：1字节8位

取值范围：-128 ~ 127

---

长整型数值有一个后缀 L 或 l ( 如 4000000000L) 

十六进制数值有一个前缀 Ox 或 0X (如 OxCAFE) 

八进制有一个前缀 0 ( 如 010 )

从 Java 7 开始， 加上前缀 0b 或 0B 就可以写二进制数。还可以为数字字面量加下划线，如用 1_000_000(或0b1111\_ 0100\_ 0010\_ 1000\_ 0000 ) 表示一百万。这些下划线只是为了让人更易读。Java 编译器会去除这些下划线

---

#### 其他说明

**注：与C++不同， Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。**

---

### 浮点型

#### float

存储需求：4字节32位

取值范围：大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位）


#### double

存储需求：8字节64位

取值范围：大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位)

---

#### 其他说明

float 类型的数值有一个后缀 F 或 f (例如，3.14F。)

没有后缀 F 的浮点数值（如 3.14 ) 默 认为 double 类型。

当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D) 。

---

绝大部分应用程序都采用 double 类型。在很多情况下，float 类型的精度很难满足需求。

---

 可以使用十六进制表示浮点数值。例如，0.125=2<sup>-3</sup> 可以表示成 0x1.0p-3。在十六进制表示法中， 使用 p 表示指数， 而不是 e。 注意， 尾数采用十六进制，指数采用十进制。指数的基数是 2，而不是 10。

---

浮点数值不适用于无法接受舍入误差的金融计算中。 例如，命令 System.out.println ( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是人们想象的 0.9。这种舍入误差的主要 原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。这 就好像十进制无法精确地表示分数 1/3 —样。如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecial类

---

### Char类型和Unicode

存储需求：4字节32位

取值范围：0 ~ 65535

---

#### 其他说明

转义序列 \u还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以）。

例如： 

```java
public static void main(String\u005B\ u00SD args) 
```

就完全符合语法规则， \u005B 和 \u005D 是 [ 和 ] 的编码。

---

char 类型原本用于表示单个字符。不过，现在情况已经有所变化。 如今，有些 Unicode 字符可以用一个 char值描述，另外一些 Unicode 字符则需要两个 char 值。

---

在 Java 中，char 类型描述了 UTF-16 编码中的一个代码单元。 我们强烈建议不要在程序中使用 char 类型，除非确实需要处理 UTF-16 代码单元。最好 将字符串作为抽象数据类型处理

---

### Boolean

存储需求：1位

boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间 不能进行相互转换。

---

在 C++ 中， 数值甚至指针可以代替 boolean 值。值 0 相当于布尔值 false, 非 0 值相当于布尔值 true, 在 Java 中则不是这样，, 因此， Java 程序员不会遇到下述麻烦：

``` Java
if (x = 0) // oops... meant x = 0
```

 在 C++ 中这个测试可以编译运行， 其结果总是 false: 而在 Java 中， 这个测试将不 能通过编译， 其原因是整数表达式 x = 0 不能转换为布尔值。

## 基本运算

### 运算符

#### 优先级


| 运算符 | 优先级 |   结合性    |
| :-------: | :---------: | :---------: |
| [] . () (方法调用) |   1    | 从左向右 |
| ! ~ ++ + (正号) - (负号) ()(强制类型转换) new |    2     | 从右向左 |
| * / % |    3     | 从左向右 |
| + - |    4     | 从左向右 |
| << >> <<< |    5     | 从左向右 |
| <  <= > >= instanceof |    6     | 从左向右 |
| == != |    7     | 从左向右 |
| & |    8     | 从左向右 |
| ^ |    9     | 从左向右 |
| \| |    10    | 从左向右 |
| && |    11    | 从左向右 |
| \|\| |    12    | 从左向右 |
| ? : |    13    | 从左向右 |
| = += -= *= /= %=  &= \|= ^= <<= >>= >>>= | 14 | 从左向右 |



## 引用数据类型

## 数组

### 定义

```java
//方法一：数据类型[] 变量名;
int[] a1;		//一维int数组
int[][] a2;		//二维int数组
String[] s;		//一维String数组

//(不推荐)方法二：数据类型 变量名[]  //C式定义
int a1[];		//一维int数组
int a2[][];		//二维int数组
String s[];		//一维String数组

//特殊命名
int[] x, y[]	//x是一维int数组，y是二维int数组
```

### 初始化

```java
//动态初始化	(数组声明且为数组元素分配空间与赋值的操作分开进行)
int[] a1 = new int [5];	
a1[0] = 0;
a1[1] = 1;

int n = 3;
int[] a2 = new int [n];		//数组的初始化长度可以填变量

int[][] a3 = new int[5][];	//和C系不同的是，Java初始化多维数组必须要填高维，而C必须要填低位
a3[0] = new int[3];
a3[1] = new int[5];			//多维数组的每一维长度可以不一

String[] a = new String[5];
a = new String[]{"Hello"," ","World","!"};
```

```java
//静态初始化(在定义数组的同时就为数组元素分配空间并赋值。)
int[] a1 = {1,2,3};			//这种方法可以不写new
int[] a2 = new int[]{1,2,3}; //要写也可以

int[][] a3 = {{1,2},{},{1,2,3}};//多维数组长度可以不相同，也可以为0

String[] a = {"Hello"," ","World","!"};
```

```java
//不合法的初始化
int[] a4 = new int[5]{1,2,3,4,5}; //new int[]括号中不可以填数字

int[] a5 = new int[3];			 //这是正确的
a5 = {1,2,3};					//错误的
a5 = new int[]{1,2,3,4,5};		 //正确的
a5 = new int[8];				//也正确(会覆盖掉原有数据)

String[] a = new String[5];		//正确的
a = {"Hello"," ","World","!"};	//错误的
```

### 题外话

#### toString

```java
int[] arr = { 1, 2, 3, 4, 5 };  
String arrString = Arrays.toString(arr);  //需要import java.util.Arrays;
   
// 直接输出，为内存地址
System.out.println(arr);  
// [I@139a55
   
System.out.println(arrString );  
// [1, 2, 3, 4, 5]
---------------------------------------------------------
int[] arr = new int[0];  
String arrString = Arrays.toString(arr);

System.out.println(arr);  
// [I@139a55

System.out.println(arrString );  
// []
```



#### 长度为0的数组和null数组

##### 区别

```java
int[] a;				//打印a时会报错，提示a未初始化
int[] a= null;			//调用a的方法时会出错，提示NPE(NullPointerException)
int[] a= new int[0];	//可以调用a的方法
```



##### 长度为0的数组作用

```java
//示例：交换数组
public static void main(String[] args) {
	int a[]=new int[0];
	int b[]=new int[2];
	int c[]=new int[2];
	b[0]=1;b[1]=1;
	c[0]=2;c[1]=2;
	System.out.println("交换前：");
	System.out.println("b[0]="+b[0]+" b[1]="+b[1]+" c[0]="+c[0]+" c[1]="+c[1]);
	a=b;
	b=c;
	c=a;
	System.out.println("交换后：");
	System.out.println("b[0]="+b[0]+" b[1]="+b[1]+" c[0]="+c[0]+" c[1]="+c[1]);
}
```

```
输出结果：
交换前：
b[0]=1 b[1]=1 c[0]=2 c[1]=2
交换后：
b[0]=2 b[1]=2 c[0]=1 c[1]=1
```



## 其他说明

### 类型转换

#### 显式类型转换

使用(类型名称)将原类型强制转换成目标类型

主要用于**高**精度基本数据类型转换成**低**精度基本数据类型（存在精度损失）或者

- 从浮点型转换成整形会直接抹去小数

### 隐式类型转换

主要是低精度类型自动升为高精度类型

例：

- 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。数字类型的从小到大分别是byte、short、int、long、float、double。
- short和byte还有char变量在进行基本数据运算时会先隐式转换成int类型运算完再自动隐式转换成short/byte/char（前提是未超过类型范围）
- 当把任何基本类型的值和字符串值进行连接运算时(+)，基本类型的值将自动转化为字符串类型。

> 数字类型的运算中，多个相同类型变量参与的运算，变量要先转换为相对应的数据类型的默认类型（比如两个byte类型的变量相加，会先把两个byte类型的变量转换成默认的int类型之后再计算，得到的结果是int类型）。
> byte,short, char之间不会相互转换，他们三者在计算时首先转换为int类型。

### 注

Boolean类型不可以转换成其他**基本**数据类型，其他**基本**类型亦不可以转换成Boolean类型

